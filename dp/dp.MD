- dp는 계산을 효율적으로 하는 것이다

- 한 번 계산한 것은 2번 계산하지 않는다
    
  구현할 때는 처음 정점에 도착하면 일반적인 방법으로 계산.
  
  2번째부터 도착했을 때는 다시 계산하지 않고 계산된 값을 사용하도록 처리하여 계산량을 줄이는 것이 핵심

- 메모화 재귀, 재귀 없이 하는 방식
- knapsack 문제
  
  가치와 무게를 가진 물건들이 있고, 

  일정한 무게까지 배낭에 넣을 수 있다고 할 때 가치의 합계를 최대로 만들려면 어떤 물건을 배낭에 담아야 할 지

  => 배낭에 담는다 / 담지 않는다 2 가지 선택밖에 없음이 본질

  *** 만약 무게 제한이 엄청 커진다면? *** => dp[idx][weigth sum]으로 메모 못 해
  
  이럴 경우 dp[idx][value sum] 으로 메모하는 방식으로 해결할 수 있다!?

- 이처럼 관점에 따라 dp의 실행 속도가 매우 달라질 수 있다.

  그래서 dp를 잘 적용하려면 다양한 관점에서 문제를 바라보는 것이 중요하다고 함..

